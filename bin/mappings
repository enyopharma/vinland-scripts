#!/usr/bin/env perl
use strict;
use warnings;
use DBI;
use JSON qw(from_json);
use Data::Dumper;

my $drakkar = DBI->connect(
    sprintf('DBI:Pg:database=%s;host=%s', 'drakkar', $ENV{'DB_PROD_HOSTNAME'}),
    $ENV{'DB_PROD_USERNAME'},
    $ENV{'DB_PROD_PASSWORD'},
);

my $vinland = DBI->connect(
    sprintf('DBI:Pg:database=%s;host=%s', 'vinland', $ENV{'DB_DEV_HOSTNAME'}),
    $ENV{'DB_DEV_USERNAME'},
    $ENV{'DB_DEV_PASSWORD'},
);

my $select_descriptions_sth = $drakkar->prepare('
    SELECT stable_id, pmid, psimi_id, accession1, name1, mapping1, accession2, name2, mapping2
    FROM dataset
    WHERE type = \'vh\'
    AND state = \'curated\'
    AND is_obsolete1 IS FALSE
    AND is_obsolete2 IS FALSE
    AND deleted_at IS NULL
    ORDER BY accession1 ASC, accession2 ASC
');

my $select_protein_sth = $
vinland->prepare('
    SELECT * FROM proteins WHERE accession = ? AND name = ?
');

my $select_edge_sth = $vinland->prepare('
    SELECT * FROM edges WHERE source_id = ? AND target_id = ?
');

my $select_sequence_sth = $vinland->prepare('
    SELECT * FROM sequences WHERE protein_id = ? AND accession = ?
');

my $select_description_sth = $vinland->prepare('
    SELECT d.id
    FROM methods AS m, interactions AS i, descriptions AS d
    WHERE m.id = d.method_id AND i.id = d.interaction_id
      AND d.pmid = ?
      AND m.psimi_id = ?
      AND i.protein1_id = ?
      AND i.protein2_id = ?
');

my @alignments = ();

$select_descriptions_sth->execute;

while (my $description = $select_descriptions_sth->fetchrow_hashref) {
    my @entries = ();

    my $mapping1 = from_json($description->{'mapping1'});
    my $mapping2 = from_json($description->{'mapping2'});

    next if @{$mapping1} == 0 && @{$mapping2} == 0;

    $select_protein_sth->execute($description->{'accession1'}, $description->{'name1'});
    my $protein1 = $select_protein_sth->fetchrow_hashref;
    $select_protein_sth->finish;

    die(sprintf('protein not found %s - %s', $description->{'accession1'}, $description->{'name1'})) unless $protein1;

    $select_protein_sth->execute($description->{'accession2'}, $description->{'name2'});
    my $protein2 = $select_protein_sth->fetchrow_hashref;
    $select_protein_sth->finish;

    die(sprintf('protein not found %s - %s', $description->{'accession2'}, $description->{'name2'})) unless $protein2;

    my @sorted = sort {
        return +1 if ($a->{'type'} eq 'v');
        return -1 if ($b->{'type'} eq 'v');
        return $a->{'accession'} cmp $b->{'accession'};
    } ($protein1, $protein2);

    $select_description_sth->execute($description->{'pmid'}, $description->{'psimi_id'}, $sorted[0]->{'id'}, $sorted[1]->{'id'});
    my ($description_id) = $select_description_sth->fetchrow_array;
    $select_description_sth->finish;

    die('description not found') unless $description;

    push(@entries, {'mapping' => $mapping1, 'source_id' => $protein1->{'id'}, 'target_id' => $protein2->{'id'}}) if (@{$mapping1} > 0);
    push(@entries, {'mapping' => $mapping2, 'source_id' => $protein2->{'id'}, 'target_id' => $protein1->{'id'}}) if (@{$mapping2} > 0);

    foreach my $entry (@entries) {
        $select_edge_sth->execute($entry->{'source_id'}, $entry->{'target_id'});
        my $edge = $select_edge_sth->fetchrow_hashref;
        $select_edge_sth->finish;

        die(sprintf('edge not found %s - %s', $entry->{'source_id'}, $entry->{'target_id'})) unless $edge;

        foreach my $mapping (@{$entry->{'mapping'}}) {
            foreach my $isoform (@{$mapping->{'isoforms'}}) {
                $select_sequence_sth->execute($entry->{'source_id'}, $isoform->{'accession'});
                my $sequence = $select_sequence_sth->fetchrow_hashref;
                $select_sequence_sth->finish;

                die(sprintf('sequence not found %s - %s', $entry->{'source_id'}, $isoform->{'accession'})) unless $sequence;

                foreach my $occurrence (@{$isoform->{'occurrences'}}) {
                    push(@alignments, [
                        $edge->{'id'},
                        $sequence->{'id'},
                        $description_id,
                        $occurrence->{'start'},
                        $occurrence->{'stop'},
                        $occurrence->{'identity'},
                        $mapping->{'sequence'},
                    ]);
                }
            }
        }
    }
}

$select_descriptions_sth->finish;

$vinland->do('COPY mappings (edge_id, sequence_id, description_id, start, stop, identity, sequence) FROM STDIN');

$vinland->pg_putcopydata(join("\t", @{$_}) . "\n") foreach (@alignments);

$vinland->pg_putcopyend();
