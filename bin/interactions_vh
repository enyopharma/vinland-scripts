#!/usr/bin/env perl
use strict;
use warnings;
use DBI;
use List::Util qw(uniq);
use Sort::Key::Natural qw(natsort);
use Data::Dumper;

my $drakkar_db = shift @ARGV or die('no drakkar db');
my $vinland_db = shift @ARGV or die('no vinland db');

my $drakkar = DBI->connect(
    sprintf('DBI:Pg:database=%s;host=%s', $drakkar_db, $ENV{'DB_DEV_HOSTNAME'}),
    $ENV{'DB_DEV_USERNAME'},
    $ENV{'DB_DEV_PASSWORD'},
);

my $vinland = DBI->connect(
    sprintf('DBI:Pg:database=%s;host=%s', $vinland_db, $ENV{'DB_DEV_HOSTNAME'}),
    $ENV{'DB_DEV_USERNAME'},
    $ENV{'DB_DEV_PASSWORD'},
);

my $select_descriptions_sth = $drakkar->prepare('
    SELECT pmid, psimi_id, accession1, name1, accession2, name2
    FROM dataset
    WHERE type = \'vh\'
    AND state = \'curated\'
    AND is_obsolete1 IS FALSE
    AND is_obsolete2 IS FALSE
    AND deleted_at IS NULL
    ORDER BY accession1 ASC, accession2 ASC
');

my $select_protein_sth = $vinland->prepare('
    SELECT * FROM proteins WHERE accession = ? AND name = ?
');

my %interactions = ();

$select_descriptions_sth->execute;

while (my $description = $select_descriptions_sth->fetchrow_hashref) {
    $select_protein_sth->execute($description->{'accession1'}, $description->{'name1'});
    my $protein1 = $select_protein_sth->fetchrow_hashref;
    $select_protein_sth->finish;

    die(sprintf('protein not found %s - %s', $description->{'accession1'}, $description->{'name1'})) unless $protein1;

    $select_protein_sth->execute($description->{'accession2'}, $description->{'name2'});
    my $protein2 = $select_protein_sth->fetchrow_hashref;
    $select_protein_sth->finish;

    die(sprintf('protein not found %s - %s', $description->{'accession2'}, $description->{'name2'})) unless $protein2;

    my $accession1 = $protein1->{'accession'};
    my $accession2 = $protein2->{'accession'};
    my $name2 = $protein2->{'name'};

    if ($interactions{$accession1}->{$accession2}->{$name2}) {
        push(@{$interactions{$accession1}->{$accession2}->{$name2}->{'publications'}}, $description->{'pmid'});
        push(@{$interactions{$accession1}->{$accession2}->{$name2}->{'methods'}}, $description->{'psimi_id'});
    } else {
        $interactions{$accession1}->{$accession2}->{$name2} = {
            'type' => 'vh',
            'protein1_id' => $protein1->{'id'},
            'protein2_id' => $protein2->{'id'},
            'publications' => [$description->{'pmid'}],
            'methods' => [$description->{'psimi_id'}],
        };
    }
}

$select_descriptions_sth->finish;

$vinland->do('COPY interactions (type, protein1_id, protein2_id, sources, nb_publications, nb_methods) FROM STDIN');

foreach my $accession1 (natsort keys %interactions) {
    foreach my $accession2 (natsort keys %{$interactions{$accession1}}) {
        foreach my $name2 (natsort keys %{$interactions{$accession1}->{$accession2}}) {
            $vinland->pg_putcopydata(join("\t", (
                $interactions{$accession1}->{$accession2}->{$name2}->{'type'},
                $interactions{$accession1}->{$accession2}->{$name2}->{'protein1_id'},
                $interactions{$accession1}->{$accession2}->{$name2}->{'protein2_id'},
                '{ENYO}',
                scalar(uniq @{$interactions{$accession1}->{$accession2}->{$name2}->{'publications'}}),
                scalar(uniq @{$interactions{$accession1}->{$accession2}->{$name2}->{'methods'}}),
            )) . "\n");
        }
    }
}

$vinland->pg_putcopyend();
